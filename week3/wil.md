## 1.Repository 계층
- Repository 
    - 데이터베이스에 접근하여 CRUD 작업을 수행하는 계층
        - Create
        - Read
        - Update
        - Delete
## 2.ORM과 JPA
데이터 베이스에 접근하려면?
- 애플리케이션 서버는 DB에 연결된 커넥션으로 SQL을 전달한다.
- DB는 전달된 SQL을 수행하고 그 결과를 응답, 애플리케이션 서버는 결과를 활용
### JDBC
- Java에서 Database에 접근하기 위한 표준화 된 API  
: Mysql이든 PostgreSql든 DB에 상관 없이 표준화 한거임.

### SQL을 직접 다루는 방식의 단점
- 반복적인 SQL 코드 작성
- SQL에 의존적인 개발
- 객체 - 데이터베이스 간 패러다임 불일치  
테이블에는 추상과 캡슐화 가용성... 등 객체지향 개념이 없음  

### ORM
위의 문제를 해결하기 위해 Object-Relational Mapping의 등장
- 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것.
- 객체 - 데이터베이스 패러다임 문제 해결

### JPA
Java Persistence API으로 자바 진영의 ORM 기술 표준  
자바에서 객체를 데이터베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API  
대표적인 JPA 구현체는 Hibernate
- 개발자가 JDBC를 사용하지 않아도 자동으로 사용해줌

## 3.JPA의 동작 방식

### EntityManager
엔티티 객체를 데이터베이스와 연결해주는 창구 역할
- JPA의 기능을 대부분은 엔티티 매니저가 제공
- 엔티티 메니저를 사용해서 SQL을 직접 작성하지 않고도 엔티티를 데이터베이스에 작업 가능
- 엔티티 메니저는 엔티티 **영속성 컨텍스트**에 저장

### 영속성 컨텍스트
JPA에서 엔티티를 관리하기 위해서 만들어져있는 가상 공간  
엔티티 매니저를 통해 영속성 컨텍스트에 접근

- 엔티티 생명 주기
    - 비영속 : 영속성 컨텍스트와 관련 없는 상태
    - 영속 : 영속성 컨텍스트에 저장된 상태. 엔티티가 관리됨
    - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태.
    - 삭제 : 영속성 컨텍스트에 엔티티가 삭제될거라고 기록한 상태.

### 영속성 컨텍스트의 특징
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지

#### 트랜잭션을 지원하는 쓰기 지원
데이터베이스에 바로 쓰는 게 아니라  
변경사항들을 모아두었다가 트랜잭션이 완료(커밋)되는 시점에 한번에 묶어서 DB에 보내는 구조.  
쿼리를 데이터베이스에 한 번에 전달할 수 있음  
장점 : 데이터베이스와의 네트워킹 횟수를 줄여 성능을 최적화 할 수 있다.

### 1차 캐시
한 번 조회한 객체를 영속성 컨텍스트가 내부에 저장해두고 재사용하는 구조  
영속성 컨텍스트에 이미 등록(캐시)된 객체를 조회할 때는 데이터베이스를 거치지 않아도 된다.

### 동일성 보장
트랜잭션 안에서는 같은 엔티티를 여러번 조회해도 영속성 컨텍스트에 보관된 같은객체를  
그대로 반환하므로 항상
동일한 객체임이 보장된다

### 변경 감지 (Dirty Checking)
영속성 컨텍스트가 엔티티의 변경 사항을 자동으로 감지하고,
트랜잭션 커밋 시점에 변경 내용을 DB에 반영하는 것 
변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용


## 4.실제 코드로 구현하기